#######################################
### Worflow functions               ###
### for EcoservR                    ###
### Sandra Angers-Blondin           ###
### 11-01-2021                      ###
#######################################


# Notes -------------------------------------------------------------------

# This module uses the information extracted into the basemap to assign a habitat type to each polygon.
# The module requires at least module 01 to have run (basemap prep), and optionally (and ideally) also considers
# CORINE, Priority Habitats and the Crop Map of England.

## Still to do:
# consolidate original Ecoserv-GIS codes to remove duplication and "u" codes
# add more rules to consider extra datasets (NFI, ...) and sort out discrepancies between datasets (crome vs corine)
# add rules for Scottish datasets once modules written for them
# create a UKHab version




#' Classify Habitats (Phase 1)
#'
#' This function assigns a habitat type (modified from Phase 1 codes) to each polygon in the basemap according to the information available. Requires at least the basemap preparation function to have run, and optionally (and ideally) also considers CORINE, Priority Habitats, the Crop Map of England, hedgerows, and elevation data.

#' @param mm The mm object loaded in the environment, can be at various stages of updating.
#' @param studyAreaBuffer The buffered study area generated during mod01 or reloaded when resuming a session.
#' @param projectLog The RDS project log file generated by the wizard app and containing all file paths to data inputs and model parameters
#' @return Saves a project_title_MM_07.RDS file to project folder
#' @export

classify_map <- function(mm = parent.frame()$mm,
                    projectLog = parent.frame()$projectLog){

   timeA <- Sys.time() # start time


   ## Extract parameters from project log -----

   # arable_min <- projectLog$params
   # gardenshape
   # gardensize
   # housemax
   # housemin
   # improved_max
   # montane
   # slope_dry
   # slope_semi
   # slope_unimp
   # upland


   # Preparation -------------------------------------------------------------

   # Make sure we have single-part polygons and calculate area afresh

   mm <- lapply(mm, function(x)
      dplyr::mutate(x,
             shp_area = as.numeric(sf::st_area(x)),
             shp_length = as.numeric(lwgeom::st_perimeter(x))) %>%
         dplyr::mutate(
            shp_index = (pi * ((shp_length / (2 * pi)) ^ 2)) / shp_area
         )
   )


   ### maybe we could work on a non-spatial object (indexed) and merge back into basemap after?









} # end of function
