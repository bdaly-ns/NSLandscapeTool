#######################################
### Worflow functions               ###
### for EcoservR                    ###
### Sandra Angers-Blondin           ###
### 11-01-2021                      ###
#######################################


# Notes -------------------------------------------------------------------

# This module uses the information extracted into the basemap to assign a habitat type to each polygon.
# The module requires at least module 01 to have run (basemap prep), and optionally (and ideally) also considers
# CORINE, Priority Habitats and the Crop Map of England.

## Still to do:
# consolidate original Ecoserv-GIS codes to remove duplication and "u" codes
# add more rules to consider extra datasets (NFI, ...) and sort out discrepancies between datasets (crome vs corine)
# add rules for Scottish datasets once modules written for them
# create a UKHab version




#' Classify Habitats (Phase 1)
#'
#' This function assigns a habitat type (modified from Phase 1 codes) to each polygon in the basemap according to the information available. Requires at least the basemap preparation function to have run, and optionally (and ideally) also considers CORINE, Priority Habitats, the Crop Map of England, hedgerows, and elevation data.

#' @param mm The mm object loaded in the environment, can be at various stages of updating.
#' @param studyAreaBuffer The buffered study area generated during mod01 or reloaded when resuming a session.
#' @param projectLog The RDS project log file generated by the wizard app and containing all file paths to data inputs and model parameters
#' @return Saves a project_title_MM_07.RDS file to project folder
#' @export

classify_map <- function(mm = parent.frame()$mm,
                    projectLog = parent.frame()$projectLog){

   timeA <- Sys.time() # start time


   ## Extract parameters from project log -----

   params <- projectLog$params


   ## Check that mm is right format

      if (!inherits(mm, "list")){
      mm <- list(mm)
   }


   # Preparation -------------------------------------------------------------

   # Make sure we have single-part polygons and calculate area afresh

   mm <- lapply(mm, function(x) checkgeometry(x, "POLYGON") %>%
                   dplyr::mutate(
                      shp_area = as.numeric(sf::st_area(x)),
                      shp_length = as.numeric(lwgeom::st_perimeter(x))) %>%
         # calculate shape index
         dplyr::mutate(
            shp_index = (pi * ((shp_length / (2 * pi)) ^ 2)) / shp_area
         )
   )


   ### maybe we could work on a non-spatial object (indexed) and merge back into basemap after?

   attributes <- unique(unlist(lapply(mm, function(x) names(x))))


# First round of classification -------------------------------------------

# First we need to make sure there is a GI column (sometimes there is no coverage of OS Greenspace / Open Greenspace for small or rural sites) as it is needed in the classif_mastermap function.

   if (!"GI" %in% attributes){
      mm <- lapply(mm, function(x) create_GI(x, params))
   }


# This is the main classification step and based on MasterMap, GI, and parameters only.

   mm <- lapply(mm, function(x) classif_mastermap(x, params))


# Refine with more GI rules

   mm <- lapply(mm, function(x) classif_green(x))


# Additional classification -----------------------------------------------

## Depending on datasets, additional classification

# Priority Habitats

if ("phi" %in% attributes){

   mm <- lapply(mm, function(x) classif_phi(x))
}

# Crome and Corine

   if (any(c("crome", "corine") %in% attributes)){

   mm <- lapply(mm, function(x) classif_agri(x))
   }



} # end of function
