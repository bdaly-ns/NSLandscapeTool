##########################################
### Climate regulation demand model    ###
### for EcoservR tool                  ###
### Sandra Angers-Blondin              ###
### 08 March 2021                      ###
##########################################

#' Climate Regulation Demand Model
#'
#' Runs the climate regulation ecosystem service model, generating capacity scores based on the ability of vegetation and water bodies to cool down the temperature locally.

#' @param x A basemap, in a list of sf tiles or as one sf object. Must have attribute HabCode_B.
#' @param studyArea The boundaries of the site, as one sf object. The final raster will be masked to this shape. For best results this shape should be smaller than the basemap (which should be buffered by typically 300 m - 1km to avoid edge effects).
#' @param res Desired resolution of the raster. Default is 5 m. Range recommended is 5-10m.
#' @param local Radius (m) for focal statistics at local range (maximum distance for effectiveness). Default is 200 m.
#' @param urban Path to a folder containing the Built-up areas layer (ONS Built-up Areas). TO BE BUILT INTO TOOLKIT EVENTUALLY
#' @param urban_size Area threshold (km2) for a built-up area to have a heat island effect (default 10 km2).
#' @param pop_density Threshold below which population is not considered high enough to have a demand (sum of house pop field in radius of "local"). Default 50.
#' @param weights Vector of two: weights to give to societal and regulatory demand, respectively. Default to 1:1.
#' @param projectLog The RDS project log file generated by the wizard app and containing all file paths to data inputs and model parameters
#' @param runtitle A customised title you can give a specific model run, which will be appended to your project title in the outputs. If comparing a basemap to an intervention map, we recommend using "pre" and "post", or a short description of the interventions, e.g. "baseline" vs "tree planting".
#' #' @param save Path to folder where outputs will be saved. By default a folder will be created using your chosen run title, prefixed by "services_". Do not use this argument unless you need to save the outputs somewhere else.
#' @return Two rasters with capacity scores: one with raw scores (arbitrary units), and one rescaled 0-100 (where 100 is maximum capacity for the area).
#' @export
#'

demand_climate_reg <- function(x, studyArea, res = 5,
                               local = 200,
                               urban = NULL,
                               urban_size = 10,
                               pop_density = 50,
                               weights = c(1,1),
                               projectLog = parent.frame()$projectLog,
                               runtitle = parent.frame()$runtitle,
                               save = NULL
                               ){

   # Create output directory automatically if doesn't already exist
   if (is.null(save)){

      save <- file.path(projectLog$projpath,
                        paste0("services_", runtitle))

      if (!dir.exists(save)){
         dir.create(save)
      }
   } else {
      # if user specified their own save directory we check that it's ok
      if(!dir.exists(save) | file.access(save, 2) != 0){
         stop("Save directory doesn't exist, or you don't have permission to write to it.")}
   }

   # Create a temp directory for scratch files

   scratch <- file.path(projectLog$projpath,
                        "ecoservR_scratch")

   if(!dir.exists(scratch)){
      dir.create(scratch)
   }

   # Check that arguments are okay
   if (length(weights) != 2 | !is.numeric(weights)) stop("Weights must be a numeric vector of 2 values.")

   # if mm is stored in list, combine all before proceeding
   if (isTRUE(class(x) == "list")){
      message("Recombining basemap tiles")
      x <- do.call(rbind, x) %>% sf::st_as_sf()
      # NOT using rbindlist here because only keeps the extent of the first tile
   }


   ### Simplify mm -----

   x <- x[c("Theme", "Make", "housePop", "riskgroup", "HabCode_B")]  # keep only what we need


   #### Read in the builtup area data, tidy and prep ----

   urban <- loadSpatial(urban, filetype = guessFiletype(urban))
   urban <- do.call(rbind, urban) %>%   # bind in one sf object
      sf::st_geometry() %>%    # keep only the geometry (drop attributes)
      sf::st_as_sf()   # coerce to sf object

   # Transform if projection doesn't match

   urban <- checkcrs(urban, 27700)

   # Prepare the urban layer
   urban <- sf::st_intersection(urban, studyArea) %>%  # clip to study area
      sf::st_buffer(200) %>%  # Buffer by 200 m
      sf::st_union() %>%
      dplyr::mutate(area = as.numeric(sf::st_area(.))/1000000) %>%  # calculate shape area, in km2
      dplyr::filter(area > urban_size)  # keep only areas larger than 10km2



   ### Create raster template with same properties as mastermap -----

   r <- raster::raster()  # create empty raster
   raster::crs(r) <- sp::CRS(SRS_string = "EPSG:27700") # hard-coding datum to preserve CRS
   raster::extent(r) <- raster::extent(x)  # set same extent as the shapefile
   raster::res(r) <- res  # set resolution



}
