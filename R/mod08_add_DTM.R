#######################################
### Worflow functions               ###
### for EcoservR                    ###
### Sandra Angers-Blondin           ###
### 26 October 2020                 ###
#######################################

#' Add terrain data
#'
#' This function adds terrain data (elevation) to the basemap. Data input can be one or several rasters of tif or asc format.

#' @param mm The mm object loaded in the environment, can be at various stages of updating.
#' @param studyAreaBuffer The buffered study area generated during mod01 or reloaded when resuming a session.
#' @param projectLog The RDS project log file generated by the wizard app and containing all file paths to data inputs and model parameters
#' @return Saves a project_title_MM_08.RDS file to project folder
#' @export

add_DTM <- function(mm = parent.frame()$mm,
                      studyAreaBuffer = parent.frame()$studyAreaBuffer,
                      projectLog = parent.frame()$projectLog){

   timeA <- Sys.time() # start time


   ## Extract the file paths and other info from project log ----------------------

   output_temp <- projectLog$output_temp
   title <- projectLog$title
   scratch_path <- file.path(output_temp, "ecoservR_scratch")
   if (!dir.exists(scratch_path)) dir.create(scratch_path)

   # Get path
   terrainpath <- projectLog$df[projectLog$df$dataset == "terrain", ][["path"]]  # path to corine data, if available


   if (!is.na(terrainpath) & !is.null(terrainpath)){
      message("Preparing to update baseline with DTM data...")

 # DATA IMPORT ---------------------------------------------------------------------------------

   # Check all files at specified path
      dtm <- list.files(terrainpath, # folder with DTM tiles
                        pattern = paste(c(".asc$", ".tif$"),collapse="|"),  # find all tif or asc files
                        all.files=TRUE, full.names=TRUE,
                        recursive = TRUE)

   # Read in the dtm tiles
      dtm <- lapply(dtm, function(x) raster::raster(x))


   ## If no projection set, flash a warning and assign OSGB1936

      if (is.na(raster::crs(dtm[[1]]))){

         message("Warning! No projection set for your DTM so we will assume it is OSGB 1936 (British National Grid).")


         lapply(dtm, function(x){
            raster::crs(x) <- sp::CRS(SRS_string = "EPSG:27700")
            return(x)
         })

      }

# TILE IF NEEDED ------------------------------------------------------------------------------

## If there is only one raster, we tile using OS grid to match grid ref of mm:

if (length(dtm) == 1){

   # we can call the object "grid" directly

   gridSA <- suppressWarnings(sf::st_intersection(grid, studyAreaBuffer))  # create gridded study area

   gridSA$TILE_NAME <- droplevels(gridSA$TILE_NAME)  # drop squares that are not in the study area

   dtm_tiles <- vector("list", length = nrow(gridSA))  # create empty list that we will fill with tiles
   names(dtm_tiles) <- gridSA$TILE_NAME

   # Create the dtm tiles for each 10x10km square in study area, and save to temporary folder defined previously
         for (i in 1:length(dtm_tiles)){
            dtm_tiles[[i]] <- raster::crop(dtm[[1]], gridSA[gridSA$TILE_NAME == names(dtm_tiles)[[i]],],
                                   filename = file.path(scratch_path, paste("dtm_tile", i, sep = "")),
                                   overwrite = TRUE)

         }

         dtm <- dtm_tiles
         rm(dtm_tiles)

      }

      # If the mm was already tiles, then these tiles have been imported in the dtm list object, and there's nothing else to do. (The extraction function will be slower because needs to find the overlapping geometries.)

# EXTRACTION ----------------------------------------------------------------------------------

      message("Extracting DTM data...")

      ## Here we need to use the old workflow that allows for any number of tiles as we don't know what they are (could be Terrain 5: 5 km tiles, or Terrain 50, etc, and do not necessarily match the 10x10km tiles)

      mm <- mapply(function(x, n) extractRaster(x, dtm, fun = "mean", tile = NULL, newcol = "elev"),
                   x = mm,
                   n = names(mm), # passing the names of the tiles will allow to select corresponding raster, making function faster. If user is not working with named tiles, will be read as null and the old function will kick in (slower but works)
                   SIMPLIFY = FALSE)  # absolutely necessary



      # SLOPES ------------------------------------------------------------------

      message("Calculating slopes...")

      # Calculate slopes from the DTM; they automatically keep their name
      slopes <- lapply(dtm, function(x) raster::terrain(x, opt = "slope", unit = "degrees"))

      rm(dtm)

      message("Extracting slopes...")
      # Extract into map
      mm <- mapply(function(x, n) extractRaster(x, slopes, fun = "mean", tile = n, newcol = "slope"),
                   x = mm,
                   n = names(mm), # passing the names of the tiles will allow to select corresponding raster, making function faster. If user is not working with named tiles, will be read as null and the old function will kick in (slower but works)
                   SIMPLIFY = FALSE)  # absolutely necessary

      rm(slopes)

      # SAVE UPDATED MASTER MAP ---------------------------------------------------------------------

      saveRDS(mm, file.path(output_temp, paste0(title,"_MM_08.RDS")))

      # Update the project log with the information that map was updated

      projectLog$last_success <- "MM_08.RDS"

      timeB <- Sys.time() # stop time

      # add performance to log
      projectLog$performance[["add_DTM"]] <- as.numeric(difftime(
         timeB, timeA, units="mins"
      ))

      updateProjectLog(projectLog) # save revised log

      # and delete contents of scratch folder
      cleanUp(scratch_path)


      message(paste0("Finished updating with elevation data. Process took ",
                     round(difftime(timeB, timeA, units = "mins"), digits = 1),
                     " minutes."))



     } else {message("No elevation data input specified.")} # end of running condition


# Return mm to environment, whether it has been updated or not.
      return({
         invisible({
            mm <<- mm
            projectLog <<- projectLog
         })
      })

} # end of function

