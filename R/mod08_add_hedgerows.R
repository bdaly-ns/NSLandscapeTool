#######################################
### Worflow functions               ###
### for EcoservR                    ###
### Sandra Angers-Blondin           ###
### 22 April 2021                   ###
#######################################

#' Add Hedgerows
#'
#' This function adds hedgerow data to the basemap. As opposed to the other basemap processing functions that extract information into existing polygons, this function creates new geometries within the basemap. Data input for hedgerows must be linear features.

#' @param mm The mm object loaded in the environment, can be at various stages of updating.
#' @param studyAreaBuffer The buffered study area generated during mod01 or reloaded when resuming a session.
#' @param projectLog The RDS project log file generated by the wizard app and containing all file paths to data inputs and model parameters
#' @return Saves a project_title_MM_08.RDS file to project folder
#' @export

add_hedgerows <- function(mm = parent.frame()$mm,
                          studyAreaBuffer = parent.frame()$studyAreaBuffer,
                          projectLog = parent.frame()$projectLog){

   timeA <- Sys.time() # start time


   ## Extract the file paths and other info from project log ----------------------

   output_temp <- projectLog$output_temp
   title <- projectLog$title
   scratch_path <- file.path(output_temp, "ecoservR_scratch")
   if (!dir.exists(scratch_path)) dir.create(scratch_path)

   # Get path
   hedgepath <- projectLog$df[projectLog$df$dataset == "hedgerows", ][["path"]]  # path to hedge data, if available
   hedgetype <- guessFiletype(hedgepath)

   if (!is.na(hedgepath) & !is.null(hedgepath)){
      message("Preparing to update baseline with hedgerow data...")


      # DATA IMPORT ---------------------------------------------------------------------------------

      # Import hedge data

      hedge <- loadSpatial(hedgepath,
                           filetype = hedgetype)  # using the loading into list function in case there are many shp

      hedge <- do.call(rbind, hedge) %>% sf::st_as_sf()  # putting back into one single sf object


      # DATA PREP -----------------------------------------------------------------------------------

      hedge <- checkcrs(hedge, studyAreaBuffer)

      # Clip to study area
      hedge <- suppressWarnings(sf::st_intersection(hedge, sf::st_geometry(studyAreaBuffer)))

      message("Creating hedgerows from linear features")
      # Keep only the geometry column
      # and buffer to create polygons from linear features
      hedge <- sf::st_geometry(hedge) %>%
         sf::st_buffer(1.25, endCapStyle = "ROUND", joinStyle = "MITRE")
      # rounded ends give best results when unioning, even if add an extra meter to the end of the hedge

      # The union is necessary to remove overlap (takes a while)

      message("Unioning hedgerows to remove overlaps")

      hedge <- sf::st_union(hedge) %>%
         sf::st_as_sf() %>%
         rmapshaper::ms_explode() # union and convert to single-part poly



      # Trim hedges -------------------------------------------------------------

      # Trim hedges so that the buffer doesn't encroach on structures (buildings and roads)

      for (i in 1:length(mm)){
         message("Reshaping hedgerows, tile ", names(mm)[[i]])

         # Get index of manmade features for that tile
         index <- (mm[[i]][["Make"]] == "Manmade" | mm[[i]][["Theme"]] == "Water")

         if (any(index)){
            hedge <- rmapshaper::ms_erase(hedge, mm[[i]][index,]) %>%  # mask
               checkgeometry(.)
         }
      }


      # Remove land from mm -----------------------------------------------------


      ## In each tile, identify which mastermap polygons intersect the hedges.
      ## Remove the shape of the hedges from them


      for (i in 1:length(mm)){
         message("Preparing basemap to receive hedgerows, tile ", names(mm)[[i]])

         # creating indices so we subset out the smaller amount of data possible
         indexmm <- which(lengths(sf::st_intersects(mm[[i]], hedge))>0)  # to subset mm poly intersecting


         if (length(indexmm) > 0){ # only erase if there are features

            indexh <- which(lengths(sf::st_intersects(hedge, mm[[i]][indexmm,]))>0)

            # create a subset with the revised polygons
            mm_erased <- rmapshaper::ms_erase(mm[[i]][indexmm,], hedge[indexh,]) %>%
               checkgeometry(.)

            # remove the original polys from df
            mm[[i]] <- mm[[i]][-indexmm,]

            # and merge the new set in
            mm[[i]] <- rbind(mm[[i]], mm_erased)
            rm(mm_erased)

         }
      }



      # Burn in hedges ----------------------------------------------------------
      message("Burning hedges into basemap")

      ## Intersect hedges to assign them to a grid reference

      hedge <- hedge %>%
         sf::st_make_valid() %>%
         sf::st_intersection(ecoservR::grid) %>%
         dplyr::select(OStile = TILE_NAME)


      ## Add columns to hedges to correspond with mm attributes

      mmcols <- setdiff(names(mm[[1]]), names(hedge))  # mm cols not present in hedge col

      hedge[mmcols] <- NA  # ready for binding

      # Populate attributes
      hedge <- hedge %>% dplyr::mutate(Term = "Hedgerow",
                                       Group = "Natural Environment",
                                       Make = "Natural",
                                       Theme = "Land"
      )


      ## Bind hedges into corresponding mm list element

      for (i in 1:length(mm)){
         tile <- names(mm)[i]
         mm[[tile]] <- rbind(mm[[tile]],
                             dplyr::filter(hedge, OStile == tile) %>% dplyr::select(-OStile))
      }


      ## Check that geometry column has same name across all tiles

      geomcol <- lapply(mm, function(x) attr(x, "sf_column")) %>% unlist()

      if (length(unique(geomcol)) > 1){ # if there is more than 1 name for the geometry column
         message("Repairing names of geometry columns")
         mm <- lapply(mm, function(x){
            if (attr(x, "sf_column") != "geometry"){
               naming <- setNames(attr(x, "sf_column"), "geometry")
               x <- dplyr::rename(x, !!!naming)
               sf::st_geometry(x) <- "geometry" # IMPORTANT! need to tell sf where to look for new geometry col
            }

            return(x)
         })
         rm(naming)

      }
      rm(geomcol)

      suppressWarnings(rm(grid, indexmm, indexh, i, mmcols, hedge, tile) )


      # SAVE UPDATED MASTER MAP ---------------------------------------------------------------------

      saveRDS(mm, file.path(output_temp, paste0(title, "_MM_08.RDS")))

      # Update the project log with the information that map was updated

      projectLog$last_success <- "MM_08.RDS"

      timeB <- Sys.time() # stop time

      # add performance to log
      projectLog$performance[["add_hedges"]] <- as.numeric(difftime(
         timeB, timeA, units="mins"
      ))

      updateProjectLog(projectLog) # save revised log

      # and delete contents of scratch folder
      cleanUp(scratch_path)


      message(paste0("Finished updating with hedgerow data. Process took ",
                     round(difftime(timeB, timeA, units = "mins"), digits = 1),
                     " minutes."))



   } else {message("No hedgerow data input specified.")} # end of running condition


   # Return mm to environment, whether it has been updated or not.
   return({
      invisible({
         mm <<- mm
         projectLog <<- projectLog
      })
   })

} # end of function

